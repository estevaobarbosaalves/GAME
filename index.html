<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robots Frenzy</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; background: black; }
        canvas { border: none; }
        #gameMenu { position: absolute; background: rgba(0,0,0,0.8); color: white; padding: 20px; text-align: center; font-family: 'Press Start 2P', cursive; }
        #gameMenu h1 { font-size: 24px; margin-bottom: 30px; text-shadow: 2px 2px #000; }
        #gameMenu button { display: block; width: 200px; padding: 10px; margin: 10px auto; font-size: 16px; cursor: pointer; font-family: 'Press Start 2P', cursive; background: #333; color: white; border: 2px solid #666; text-transform: uppercase; }
        #gameMenu button:hover { background: #444; border-color: #888; }
        #gameMenu ul { font-size: 12px; line-height: 1.6; text-align: left; margin: 20px 0; padding-left: 20px; }
        #gameMenu p { font-size: 12px; line-height: 1.6; margin: 20px 0; }
        * {
            font-family: 'Press Start 2P', cursive;
        }
        canvas {
            font-family: 'Press Start 2P', cursive;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameMenu">
        <h1>Jogo de Plataforma 2D</h1>
        <button id="startButton">Iniciar Jogo</button>
        <button id="instructionsButton">Instruções</button>
        <button id="quitButton">Sair</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let GAME_WIDTH = 2400;
        let GAME_HEIGHT = 800;
        let SCALE_FACTOR;

        // Adicione estas variáveis globais no início do seu script
        let konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        let konamiIndex = 0;
        let easterEggActivated = false;

        // Adicione esta variável global junto com as outras no início do script
        const strongRobotSprite = new Image();
        strongRobotSprite.src = 'Medium robot.png';
        let strongRobotSpriteLoaded = false;

        strongRobotSprite.onload = function() {
            strongRobotSpriteLoaded = true;
            console.log("Sprite do robô forte carregado com sucesso");
        };

        // Adicione estas variáveis globais junto com as outras no início do script
        const weakRobotSprite = new Image();
        weakRobotSprite.src = 'pixilart-drawing.png';
        let weakRobotSpriteLoaded = false;

        weakRobotSprite.onload = function() {
            weakRobotSpriteLoaded = true;
            console.log("Sprite do robô fraco carregado com sucesso");
        };

        // Adicione esta variável global junto com as outras no início do script
        const zectromSprite = new Image();
        zectromSprite.src = 'ZECTROM].png';
        let zectromSpriteLoaded = false;

        zectromSprite.onload = function() {
            zectromSpriteLoaded = true;
            console.log("Sprite do Zectrom carregado com sucesso");
        };

        // Adicione esta variável global junto com as outras no início do script
        const backgroundImage = new Image();
        backgroundImage.src = 'Imagem do WhatsApp de 2024-11-17 à(s) 20.10.39_1ba98198.jpg';
        let backgroundLoaded = false;

        backgroundImage.onload = function() {
            backgroundLoaded = true;
            console.log("Imagem de fundo carregada com sucesso");
        };

        // Adicione esta função para verificar o código Konami
        function checkKonamiCode(e) {
            if (e.code === konamiCode[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiCode.length) {
                    easterEggActivated = true;
                    showMenu(); // Atualiza o menu com a opção de seleção de wave
                    konamiIndex = 0; // Reseta o índice para permitir nova entrada do código
                }
            } else {
                konamiIndex = 0;
            }
        }

        // Adicione este event listener no início do seu script
        document.addEventListener('keydown', checkKonamiCode);

        function resizeCanvas() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Calcule o fator de escala para mostrar o mapa inteiro
            SCALE_FACTOR = Math.min(windowWidth / GAME_WIDTH, windowHeight / GAME_HEIGHT);
            
            // Ajuste o tamanho do canvas usando CSS
            canvas.style.width = `${GAME_WIDTH * SCALE_FACTOR}px`;
            canvas.style.height = `${GAME_HEIGHT * SCALE_FACTOR}px`;
            
            // Mantenha o tamanho lógico do canvas
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            
            // Ajuste os objetos do jogo
            adjustGameObjects();
        }

        // Adicione esta função após a função resizeCanvas
        function adjustGameObjects() {
            // Aumentar o tamanho do jogador
            const spriteRatio = 7 / 11;
            player.height = GAME_HEIGHT * 0.15; // 15% da altura do jogo
            player.width = player.height * spriteRatio;
            player.speed = GAME_WIDTH * 0.002; // Reduzido de 0.004 para 0.002
            player.jumpStrength = GAME_HEIGHT * 0.025;
            
            // Ajustar a posição inicial do jogador para que fique no chão
            player.y = ground.y - player.height;
            
            ground.y = GAME_HEIGHT - GAME_HEIGHT * 0.05;
            ground.height = GAME_HEIGHT * 0.05;
            
            // Ajuste as plataformas
            platforms.forEach(platform => {
                platform.width = GAME_WIDTH * 0.08;
                platform.height = GAME_HEIGHT * 0.02; // Reduzido um pouco para manter a proporção
            });
            
            // Ajustar o tamanho e a velocidade do projétil
            bullet.radius = GAME_WIDTH * 0.004; // 0.4% da largura do jogo
            bullet.speed = GAME_WIDTH * 0.004; // 0.4% da largura do jogo
            
            // Ajustar o tamanho dos robôs
            robots.forEach(robot => {
                if (robot.isStrong) {
                    robot.width = GAME_WIDTH * 0.03;  // Aumentado de 0.02 para 0.03
                    robot.height = GAME_HEIGHT * 0.07; // Aumentado de 0.05 para 0.07
                } else {
                    robot.width = GAME_WIDTH * 0.015;
                    robot.height = GAME_HEIGHT * 0.04;
                }
            });
            
            // Ajustar o tamanho do chefe, se existir
            if (boss) {
                boss.width = GAME_WIDTH * 0.06;  // Aumentado de 0.03 para 0.06 (6% da largura do jogo)
                boss.height = GAME_HEIGHT * 0.16; // Aumentado de 0.08 para 0.16 (16% da altura do jogo)
            }
            
            // Reduzir a força do dash
            player.dashSpeed = GAME_WIDTH * 0.008
        ; // Reduzido de 0.008 para 0.004 (0.4% da largura do jogo por frame)
        }

        const player = {
            x: GAME_WIDTH / 2, y: GAME_HEIGHT - 80, width: 30, height: 50, // Aumentei a altura
            speed: 3, jumpStrength: 20,
            verticalVelocity: 0, lives: 3,
            canShoot: true, shootCooldown: 500, direction: 1,
            charging: false, chargeTime: 0, maxChargeTime: 1000,
            isCharging: false,
            chargedShots: 0,
            maxChargedShots: 3,
            overheated: false,
            overheatCooldown: 3000,
            canDash: true,
            isDashing: false,
            dashSpeed: 8,
            dashDuration: 200,
            dashCooldown: 1000,
            maxDashes: 3,
            dashesUsed: 0,
            isTired: false,
            tirednessRecovery: 3000,
            sprite: new Image(),
            spriteLoaded: false,
            idleSprite: new Image(),
            idleSpriteLoaded: false,
            idleFrames: 6,
            currentIdleFrame: 0,
            idleAnimationTimer: 0,
            isIdle: true,
            hasUltimate: true,
            ultimateCooldown: 30000, // Aumentado para 30 segundos
            lastUltimateTime: 0,
            isUsingUltimate: false,
            ultimateDuration: 1000, // Duração do laser: 1 segundo
        };

        player.sprite.onload = function() {
            player.spriteLoaded = true;
            console.log("Sprite do jogador carregado com sucesso");
            console.log("Dimensões do sprite:", player.sprite.width, player.sprite.height);
        };
        player.sprite.onerror = function() {
            console.error("Erro ao carregar o sprite do jogador");
        };
        player.sprite.src = 'pixil-frame-0.png'; // Caminho para o novo sprite

        player.idleSprite.onload = function() {
            player.idleSpriteLoaded = true;
            console.log("Sprite de idle do jogador carregado com sucesso");
        };
        player.idleSprite.onerror = function() {
            console.error("Erro ao carregar o sprite de idle do jogador");
        };
        player.idleSprite.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAALCAYAAACzkJeoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAnSURBVHgBzc4xDQAACAMwwL/TQQNvagSKFAYeVbcd5LRNyWmfkuMBXAMEAYVLHygAAAAASUVORK5CYII=';

        const bullet = { x: 0, y: 0, radius: 5, speed: 10, isActive: false, direction: 1, damage: 20, baseDamage: 10, maxDamage: 50 };

        let currentWave = 1;
        let enemiesDefeated = 0;
        const robots = [];
        const platforms = [
            {x: 400, y: 650, width: 200, height: 20},
            {x: 800, y: 550, width: 200, height: 20},
            {x: 1200, y: 450, width: 200, height: 20},
            {x: 1600, y: 350, width: 200, height: 20},
            {x: 2000, y: 250, width: 200, height: 20},
            {x: 600, y: 150, width: 200, height: 20},
            {x: 1000, y: 100, width: 200, height: 20},
            {x: 1400, y: 200, width: 200, height: 20},
            {x: 1800, y: 300, width: 200, height: 20}
        ];

        const ground = { y: GAME_HEIGHT - 30, height: 30 };

        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Adicione esta nova constante para o chefe
        const boss = {
            x: GAME_WIDTH / 2,
            y: ground.y - 180,  // Aumentado de 120 para 180
            width: 120,         // Aumentado de 60 para 120
            height: 180,        // Aumentado de 120 para 180
            speed: 2,           // Reduzido de 4 para 2
            jumpStrength: 15,   // Reduzido de 20 para 15
            health: 300,
            maxHealth: 300,
            verticalVelocity: 0,
            direction: 1,
            color: '#800080', // Roxo escuro
            active: false,
            attackCooldown: 2000,  // Aumentado de 1500 para 2000
            lastAttackTime: 0,
            projectiles: [], // Array para guardar os projéteis do boss
            attackPatterns: ['shoot', 'dash', 'jump'],
            currentPattern: 0,
            patternTimer: 0,
            isDashing: false,
            dashSpeed: 6,       // Reduzido de 12 para 6
            dashDuration: 800,     // Aumentado de 500 para 800
            dashCooldown: 3000,    // Aumentado de 2000 para 3000
            lastDashTime: 0
        };

        // Adicionar esta nova função para gerenciar os projéteis do boss
        function updateBossProjectiles() {
            for (let i = boss.projectiles.length - 1; i >= 0; i--) {
                const proj = boss.projectiles[i];
                proj.x += proj.speed * proj.direction;
                proj.y += Math.sin(proj.x / 100) * 2; // Movimento ondulante

                // Remover projéteis fora da tela
                if (proj.x < 0 || proj.x > GAME_WIDTH) {
                    boss.projectiles.splice(i, 1);
                    continue;
                }

                // Verificar colisão com o jogador
                if (checkCollision(player, {
                    x: proj.x - proj.radius,
                    y: proj.y - proj.radius,
                    width: proj.radius * 2,
                    height: proj.radius * 2
                })) {
                    player.lives--;
                    boss.projectiles.splice(i, 1);
                    if (player.lives <= 0) {
                        gameOver();
                    } else {
                        respawnPlayer();
                    }
                }
            }
        }

        // Adicionar esta função para o boss atirar
        function bossShoot() {
            const projectile = {
                x: boss.x + boss.width / 2,
                y: boss.y + boss.height / 2,
                radius: 12,
                speed: 8,
                direction: boss.direction
            };
            boss.projectiles.push(projectile);
        }

        // Modifique a função createRobot para aumentar o tamanho dos robôs fortes
        function createRobot(isStrong) {
            const baseHealth = isStrong ? 50 : 20;
            const health = baseHealth + (isStrong ? (currentWave - 1) * 10 : 0);
            return {
                x: Math.random() < 0.5 ? -30 : GAME_WIDTH,
                y: ground.y - (isStrong ? 150 : 60),  // Aumentado de 120 para 150
                width: isStrong ? 130 : 50,           // Aumentado de 100 para 130
                height: isStrong ? 150 : 60,          // Aumentado de 120 para 150
                speed: isStrong ? 2 : 1,
                jumpStrength: isStrong ? 20 : 18,
                health: health,
                maxHealth: health,
                isStrong: isStrong,
                color: isStrong ? 'red' : 'orange',
                verticalVelocity: 0,
                direction: 1
            };
        }

        function moveObject(obj) {
            obj.prevX = obj.x;
            if (obj === player) {
                if (player.isDashing) {
                    obj.x += obj.dashSpeed * obj.direction;
                } else {
                    if (keys['ArrowLeft']) { obj.x -= obj.speed; obj.direction = -1; }
                    if (keys['ArrowRight']) { obj.x += obj.speed; obj.direction = 1; }
                    if (keys['Space'] && isOnGround(obj)) { obj.verticalVelocity = -obj.jumpStrength; }
                }
            } else if (obj === boss) {
                const currentTime = Date.now();
                
                // Atualizar padrão de ataque mais lentamente
                boss.patternTimer += 12; // Reduzido de 16 para 12
                if (boss.patternTimer >= 4000) { // Aumentado de 3000 para 4000
                    boss.currentPattern = (boss.currentPattern + 1) % boss.attackPatterns.length;
                    boss.patternTimer = 0;
                }

                const pattern = boss.attackPatterns[boss.currentPattern];
                
                switch (pattern) {
                    case 'shoot':
                        if (currentTime - boss.lastAttackTime > boss.attackCooldown) {
                            bossShoot();
                            boss.lastAttackTime = currentTime;
                        }
                        // Movimento mais lento durante o ataque
                        boss.x += boss.speed * 0.3 * (player.x > boss.x ? 1 : -1); // Reduzido de 0.5 para 0.3
                        break;
                        
                    case 'dash':
                        if (!boss.isDashing && currentTime - boss.lastDashTime > boss.dashCooldown) {
                            boss.isDashing = true;
                            boss.lastDashTime = currentTime;
                            boss.direction = player.x > boss.x ? 1 : -1;
                        }
                        
                        if (boss.isDashing) {
                            boss.x += boss.dashSpeed * boss.direction * 0.8; // Reduzido para 80% da velocidade
                        }
                        break;
                        
                    case 'jump':
                        if (isOnGround(boss)) {
                            boss.verticalVelocity = -boss.jumpStrength * 0.8; // Reduzido para 80% da força
                        }
                        boss.x += boss.speed * 0.8 * (player.x > boss.x ? 1 : -1); // Reduzido para 80% da velocidade
                        break;
                }

                boss.direction = player.x > boss.x ? 1 : -1;
                boss.x = Math.max(0, Math.min(boss.x, GAME_WIDTH - boss.width));
            } else {
                obj.x += obj.speed * (obj.x < player.x ? 1 : -1);
                if (isOnGround(obj) && Math.random() < 0.01) { obj.verticalVelocity = -obj.jumpStrength; }
            }
            obj.x = Math.max(0, Math.min(GAME_WIDTH - obj.width, obj.x));
            obj.verticalVelocity += 0.6;
            const nextY = obj.y + obj.verticalVelocity;

            // Verificar colisão com plataformas
            let platformCollision = false;
            for (let platform of platforms) {
                // Verificar se o objeto está dentro da largura da plataforma
                if (obj.x + obj.width > platform.x && obj.x < platform.x + platform.width) {
                    // Caindo
                    if (obj.verticalVelocity > 0) {
                        // Verificar se o objeto vai atravessar a plataforma neste frame
                        if (obj.y + obj.height <= platform.y && nextY + obj.height >= platform.y) {
                            obj.y = platform.y - obj.height;
                            obj.verticalVelocity = 0;
                            platformCollision = true;
                            break;
                        }
                    }
                    // Subindo (colisão com a parte de baixo da plataforma)
                    else if (obj.verticalVelocity < 0) {
                        if (obj.y >= platform.y + platform.height && nextY <= platform.y + platform.height) {
                            obj.y = platform.y + platform.height;
                            obj.verticalVelocity = 0;
                            platformCollision = true;
                            break;
                        }
                    }
                }
            }

            // Se não houve colisão com plataforma, aplicar a velocidade vertical
            if (!platformCollision) {
                obj.y = nextY;
            }

            // Colisão com o chão
            if (obj.y + obj.height > ground.y) {
                obj.y = ground.y - obj.height;
                obj.verticalVelocity = 0;
            }
        }

        function isOnGround(obj) {
            return obj.y + obj.height >= ground.y || platforms.some(platform => 
                obj.y + obj.height === platform.y &&
                obj.x < platform.x + platform.width &&
                obj.x + obj.width > platform.x
            );
        }

        function shootBullet() {
            if (player.canShoot) {
                bullet.x = player.x + (player.direction === 1 ? player.width : 0);
                bullet.y = player.y + player.height / 2;
                bullet.isActive = true;
                bullet.direction = player.direction;
                let chargeFactor = Math.min(player.chargeTime / player.maxChargeTime, 1);
                bullet.damage = 20 + Math.floor(chargeFactor * 60);
                player.canShoot = false;
                setTimeout(() => { player.canShoot = true; }, player.shootCooldown);
                player.charging = false;
                player.chargeTime = 0;
            }
        }

        function updateBullet() {
            if (bullet.isActive) {
                bullet.x += bullet.speed * bullet.direction;
                // Verifique se a bala saiu dos limites do mapa
                if (bullet.x < 0 || bullet.x > GAME_WIDTH) {
                    bullet.isActive = false;
                }
            }
        }

        function initializeWave() {
            robots.length = 0;
            if (currentWave === 10) {
                boss.active = true;
                boss.health = boss.maxHealth;
                
                // Lógica para spawnar o chefe longe do jogador
                const minDistance = GAME_WIDTH / 3; // Distância mínima do jogador
                let bossX;
                
                if (player.x < GAME_WIDTH / 2) {
                    // Se o jogador estiver na metade esquerda, spawna o chefe na direita
                    bossX = Math.random() * (GAME_WIDTH / 2) + GAME_WIDTH / 2;
                } else {
                    // Se o jogador estiver na metade direita, spawna o chefe na esquerda
                    bossX = Math.random() * (GAME_WIDTH / 2);
                }
                
                // Garante que o chefe não spawne muito perto das bordas
                bossX = Math.max(boss.width, Math.min(bossX, GAME_WIDTH - boss.width));
                
                boss.x = bossX;
                boss.y = ground.y - boss.height; // Coloca o chefe no chão
            } else {
                const enemiesPerWave = Math.min(3 + Math.floor(currentWave / 2), 10);
                const strongRobots = Math.min(Math.floor(currentWave / 3), 5);
                for (let i = 0; i < enemiesPerWave; i++) {
                    robots.push(createRobot(i < strongRobots));
                }
            }
        }

        let lastTime = 0;
        let gameState = 'menu';
        let animationFrameId;

        function showMenu() {
            gameState = 'menu';
            let menuHTML = `
                <h1>Robots Frenzy</h1>
                <button id="startButton">Iniciar Jogo</button>
                <button id="instructionsButton">Instruções</button>
                <button id="quitButton">Sair</button>
            `;
            
            if (easterEggActivated) {
                menuHTML += `
                    <div id="waveSelector" style="margin-top: 20px;">
                        <h3>Selecione a Wave Inicial (1-10):</h3>
                        <input type="number" id="waveInput" min="1" max="10" value="1">
                        <button id="selectWaveButton">Iniciar na Wave Selecionada</button>
                    </div>
                `;
            }
            
            document.getElementById('gameMenu').innerHTML = menuHTML;
            document.getElementById('gameMenu').style.display = 'block';
            addMenuListeners();
        }

        function hideMenu() {
            document.getElementById('gameMenu').style.display = 'none';
        }

        function startGame() {
            gameState = 'playing';
            hideMenu();
            resizeCanvas();
            reiniciarJogo(currentWave); // Modifique esta função para aceitar a wave inicial
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        function showInstructions() {
            document.getElementById('gameMenu').innerHTML = `
                <h1>Instruções</h1>
                <p>Use as setas para mover o jogador:</p>
                <ul>
                    <li>← (Seta Esquerda): Mover para a esquerda</li>
                    <li>→ (Seta Direita): Mover para a direita</li>
                    <li>Espaço: Pular</li>
                </ul>
                <p>Controles de tiro:</p>
                <ul>
                    <li>X: Pressione e segure para carregar o tiro, solte para atirar</li>
                    <li>Cuidado com o superaquecimento após 3 tiros carregados!</li>
                </ul>
                <p>Dash:</p>
                <ul>
                    <li>Q: Realizar um dash rápido na direção do movimento</li>
                    <li>Você pode usar o dash ${player.maxDashes} vezes antes de ficar cansado</li>
                    <li>Após ficar cansado, espere um momento para recuperar o fôlego</li>
                </ul>
                <p>Objetivo: Derrote os robôs inimigos e sobreviva às ondas de ataques!</p>
                <button id="backButton">Voltar ao Menu</button>
            `;
            document.getElementById('backButton').addEventListener('click', showMenu);
        }

        function addMenuListeners() {
            const startButton = document.getElementById('startButton');
            const instructionsButton = document.getElementById('instructionsButton');
            const quitButton = document.getElementById('quitButton');
            const backButton = document.getElementById('backButton');

            if (startButton) startButton.addEventListener('click', startGame);
            if (instructionsButton) instructionsButton.addEventListener('click', showInstructions);
            if (quitButton) quitButton.addEventListener('click', () => {
                if (window.confirm('Tem certeza que deseja sair do jogo?')) {
                    window.close();
                }
            });
            if (backButton) backButton.addEventListener('click', showMenu);

            if (easterEggActivated) {
                const selectWaveButton = document.getElementById('selectWaveButton');
                if (selectWaveButton) {
                    selectWaveButton.addEventListener('click', () => {
                        const selectedWave = parseInt(document.getElementById('waveInput').value);
                        if (selectedWave >= 1 && selectedWave <= 10) {
                            currentWave = selectedWave;
                            startGame();
                        } else {
                            alert('Por favor, selecione uma wave entre 1 e 10.');
                        }
                    });
                }
            }
        }

        // Adicione um evento para pausar o jogo
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape' && gameState === 'playing') {
                gameState = 'menu';
                showMenu();
            }
        });

        // Adicione um listener de redimensionamento e chame resizeCanvas no início
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Inicialize o jogo no estado de menu
        showMenu();

        function showVictoryScreen() {
            cancelAnimationFrame(animationFrameId);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            ctx.fillStyle = 'gold';
            ctx.font = '48px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('Parabéns!', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 120);
            
            ctx.fillStyle = 'white';
            ctx.font = '24px "Press Start 2P"';
            ctx.fillText('Você derrotou Zectrom,', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40);
            ctx.fillText('tirando a frenesia dos robôs', GAME_WIDTH / 2, GAME_HEIGHT / 2);
            ctx.fillText('e os desinfectando.', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 40);
            ctx.fillText('VOCÊ SALVOU O MUNDO!', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 80);
        }

        function gameOver() {
            gameState = 'menu';
            cancelAnimationFrame(animationFrameId);
            showMenu();
            alert("Game Over! Você perdeu todas as suas vidas.");
            reiniciarJogo(); // Adicione esta linha para reiniciar o jogo
        }

        // Adicione este código no início do seu script para garantir que o canvas seja configurado corretamente
        window.onload = function() {
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            console.log("Canvas configurado com dimensões:", canvas.width, canvas.height);
            gameLoop();
        };

        // Modifique a função drawRobot para usar os sprites
        function drawRobot(ctx, robot) {
            ctx.save();
            ctx.translate(robot.x, robot.y);
            
            // Determinar a direção do robô baseado na posição do jogador
            robot.direction = robot.x < player.x ? 1 : -1;
            
            if (robot.isStrong && strongRobotSpriteLoaded) {
                // Desenhar o sprite do robô forte
                if (robot.direction === -1) {  // Invertido a condição
                    ctx.scale(-1, 1);
                    ctx.translate(-robot.width, 0);
                }
                ctx.drawImage(strongRobotSprite, 0, 0, robot.width, robot.height);
            } else if (!robot.isStrong && weakRobotSpriteLoaded) {
                // Desenhar o sprite do robô fraco
                if (robot.direction === -1) {  // Invertido a condição
                    ctx.scale(-1, 1);
                    ctx.translate(-robot.width, 0);
                }
                ctx.drawImage(weakRobotSprite, 0, 0, robot.width, robot.height);
            } else {
                // Fallback para quando os sprites não estiverem carregados
                ctx.fillStyle = robot.isStrong ? 'red' : 'orange';
                ctx.fillRect(0, 0, robot.width, robot.height);
                
                // Desenhar os "olhos" do robô
                ctx.fillStyle = 'white';
                const eyeSize = robot.width * 0.2;
                ctx.fillRect(robot.width * 0.2, robot.height * 0.2, eyeSize, eyeSize);
                ctx.fillRect(robot.width * 0.6, robot.height * 0.2, eyeSize, eyeSize);
            }
            
            // Desenhar barra de vida do robô
            const healthBarWidth = robot.width;
            const healthBarHeight = 5;
            const healthPercentage = robot.health / robot.maxHealth;
            
            ctx.fillStyle = 'red';
            ctx.fillRect(0, -10, healthBarWidth, healthBarHeight);
            ctx.fillStyle = 'green';
            ctx.fillRect(0, -10, healthBarWidth * healthPercentage, healthBarHeight);
            
            ctx.restore();
        }

        // No gameLoop, substitua a chamada para drawRobotSprite por drawRobot
        function gameLoop(currentTime) {
            if (gameState !== 'playing') {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Desenhar o background
            if (backgroundLoaded) {
                // Desenhar a imagem de fundo cobrindo todo o canvas
                ctx.drawImage(backgroundImage, 0, 0, GAME_WIDTH, GAME_HEIGHT);
            } else {
                // Fallback para cor sólida caso a imagem não carregue
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }

            // Calcular a posição da câmera
            const cameraX = Math.max(0, Math.min(player.x - canvas.width / 2, GAME_WIDTH - canvas.width));

            ctx.save();
            ctx.translate(-cameraX, 0);

            // Desenhar plataformas
            for (let platform of platforms) {
                if (platform.x + platform.width > cameraX && platform.x < cameraX + canvas.width) {
                    drawNoisyPlatform(ctx, platform.x, platform.y, platform.width, platform.height);
                }
            }

            // Desenhar chão
            drawNoisyGround(ctx, cameraX, ground.y, canvas.width, ground.height);

            // Atualizar e desenhar jogador
            moveObject(player);
            drawPlayerSprite(ctx, player);

            // Atualizar e desenhar bala
            if (bullet.isActive) {
                updateBullet();
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'yellow';
                ctx.fill();
                ctx.strokeStyle = 'orange';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Verificar colisão com robôs
                for (let i = robots.length - 1; i >= 0; i--) {
                    if (checkBulletCollision(bullet, robots[i])) {
                        robots[i].health -= bullet.damage;
                        bullet.isActive = false;
                        if (robots[i].health <= 0) {
                            robots.splice(i, 1);
                            enemiesDefeated++;
                        }
                        break;
                    }
                }

                // Verificar colisão com o chefe
                if (boss.active && checkBulletCollision(bullet, boss)) {
                    boss.health -= bullet.damage;
                    bullet.isActive = false;
                    if (boss.health <= 0) {
                        boss.active = false;
                        showVictoryScreen();
                    }
                }
            }

            // Atualizar e desenhar robôs
            robots.forEach((robot, index) => {
                moveObject(robot);
                drawRobot(ctx, robot);
                
                // Verificar colisão com o jogador
                if (checkCollision(player, robot)) {
                    player.lives--;
                    if (player.lives <= 0) {
                        gameOver();
                    } else {
                        respawnPlayer();
                    }
                }
            });

            // Atualizar e desenhar chefe (se ativo)
            if (boss.active) {
                moveObject(boss);
                updateBossProjectiles();
                
                // Desenhar o boss
                drawBoss(ctx);
                
                // Desenhar nome "Zectrom" acima do boss na wave 10
                if (currentWave === 10) {
                    ctx.fillStyle = 'white';
                    ctx.font = '24px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText('Zectrom', boss.width / 2, -30);
                }
                
                // Desenhar projéteis do boss
                boss.projectiles.forEach(proj => {
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff4444';
                    ctx.fill();
                });
                
                // Verificar colisão com o jogador
                if (checkCollision(player, boss)) {
                    player.lives--;
                    if (player.lives <= 0) {
                        gameOver();
                    } else {
                        respawnPlayer();
                    }
                }
            }

            // Adicionar antes do ctx.restore()
            spawnHealthPowerUp();
            drawHealthPowerUp(ctx);
            
            // Verificar colisão com power-up
            if (healthPowerUp.active && player.lives < 3 && checkCollision(player, healthPowerUp)) {
                player.lives++;
                healthPowerUp.active = false;
                healthPowerUp.lastSpawnTime = Date.now();
                
                // Efeito visual de cura
                ctx.save();
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                ctx.restore();
            }

            ctx.restore();

            // Desenhar UI
            drawUI();

            // Lógica de carregamento de tiro
            handleCharging(deltaTime);

            // Lógica de dash
            handleDash(deltaTime);

            // Verificar se todos os inimigos foram derrotados
            if (robots.length === 0 && !boss.active) {
                currentWave++;
                if (currentWave > 10) {
                    showVictoryScreen();
                } else {
                    initializeWave();
                }
            }

            if (player.isUsingUltimate) {
                updateUltimate();
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Funções auxiliares para melhorar a legibilidade e performance
        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText(`Vidas: ${player.lives}`, 10, 30);
            ctx.fillText(`Onda: ${currentWave}`, 10, 60);
            
            // Modificar para mostrar "Zectrom HP" na onda 10
            if (currentWave === 10 && boss.active) {
                ctx.fillText(`Zectrom HP: ${boss.health}`, 10, 90);
            } else {
                ctx.fillText(`Inimigos: ${robots.length}`, 10, 90);
            }
            
            // Desenhar indicador de tiros carregados
            for (let i = 0; i < player.maxChargedShots; i++) {
                ctx.fillStyle = i < player.chargedShots ? 'orange' : 'gray';
                ctx.fillRect(10 + i * 20, 120, 15, 15);
            }

            // Desenhar indicador de dashes disponíveis
            for (let i = 0; i < player.maxDashes; i++) {
                ctx.fillStyle = i < player.dashesUsed ? 'red' : 'blue';
                ctx.fillRect(10 + i * 20, 150, 15, 15);
            }

            if (player.overheated) {
                ctx.fillStyle = 'red';
                ctx.font = '14px Arial';
                ctx.fillText('SOBRECARREGADO!', 10, 180);
            }

            if (player.isTired) {
                ctx.fillStyle = 'red';
                ctx.font = '14px Arial';
                ctx.fillText('CANSADO!', 10, 200);
            }

            // Indicador do ultimate
            const ultimateReady = Date.now() - player.lastUltimateTime >= player.ultimateCooldown;
            ctx.fillStyle = ultimateReady ? 'gold' : 'gray';
            ctx.font = '16px "Press Start 2P"';
            ctx.fillText('ULTIMATE (U)', 10, 230);
            
            // Barra de cooldown do ultimate
            if (!ultimateReady) {
                const cooldownProgress = (Date.now() - player.lastUltimateTime) / player.ultimateCooldown;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(10, 240, 100, 10);
                ctx.fillStyle = 'gold';
                ctx.fillRect(10, 240, 100 * cooldownProgress, 10);
            }
        }

        function handleCharging(deltaTime) {
            if (keys.KeyX) {
                if (!player.isCharging && !player.overheated) {
                    player.isCharging = true;
                    player.chargeTime = 0;
                } else if (player.isCharging) {
                    player.chargeTime = Math.min(player.chargeTime + deltaTime, player.maxChargeTime);
                }
            }
        }

        function handleDash(deltaTime) {
            if (player.isDashing) {
                player.dashDuration -= deltaTime;
                if (player.dashDuration <= 0) {
                    player.isDashing = false;
                    player.dashDuration = 200;
                    player.dashesUsed++;
                    if (player.dashesUsed >= player.maxDashes) {
                        player.isTired = true;
                        player.dashesUsed = 0;
                        setTimeout(() => {
                            player.isTired = false;
                        }, player.tirednessRecovery);
                    }
                    player.canDash = false;
                    setTimeout(() => { player.canDash = true; }, player.dashCooldown);
                }
            }
        }

        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width && obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height && obj1.y + obj1.height > obj2.y;
        }

        function reiniciarJogo(initialWave = 1) {
            player.x = GAME_WIDTH / 2;
            player.y = GAME_HEIGHT - 80;
            player.lives = 3; // Redefina as vidas para 3
            player.canShoot = true;
            player.direction = 1;
            bullet.isActive = false;
            player.charging = false;
            player.chargeTime = 0;
            currentWave = initialWave;
            enemiesDefeated = 0;
            boss.active = false;
            initializeWave();
        }

        function fireBullet() {
            if (player.canShoot && !player.overheated) {
                bullet.isActive = true;
                bullet.x = player.direction === 1 ? player.x + player.width + bullet.radius : player.x - bullet.radius;
                bullet.y = player.y + player.height / 2;
                bullet.direction = player.direction;
                
                const chargePercentage = player.chargeTime / player.maxChargeTime;
                bullet.damage = bullet.baseDamage + (bullet.maxDamage - bullet.baseDamage) * chargePercentage;
                
                bullet.speed = 10 + 10 * chargePercentage;
                bullet.radius = 5 + 20 * chargePercentage;

                player.canShoot = false;
                player.isCharging = false;
                player.chargeTime = 0;

                // Use requestAnimationFrame para atrasar a recarga do tiro
                requestAnimationFrame(() => {
                    setTimeout(() => { player.canShoot = true; }, player.shootCooldown);
                });

                if (chargePercentage > 0.5) {
                    player.chargedShots++;
                    if (player.chargedShots >= player.maxChargedShots) {
                        player.overheated = true;
                        player.chargedShots = 0;
                        setTimeout(() => {
                            player.overheated = false;
                        }, player.overheatCooldown);
                    }
                }
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyX' && !player.isCharging && player.canShoot && !player.overheated) {
                player.isCharging = true;
                player.chargeTime = 0;
            }
            if (e.code === 'Space') {
                keys.Space = true;
            }
            if (e.code === 'KeyX') {
                keys.KeyX = true;
            }
            if (e.code === 'KeyQ') {
                if (player.canDash && !player.isDashing && !player.isTired) {
                    player.isDashing = true;
                    player.canDash = false;
                }
            }
            if (e.code === 'KeyU') {
                fireUltimate();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'KeyX' && player.isCharging) {
                fireBullet();
            }
            if (e.code === 'Space') {
                keys.Space = false;
            }
            if (e.code === 'KeyX') {
                keys.KeyX = false;
            }
        });

        // Substitua a função drawPlayerSprite por esta nova versão
        function drawPlayerSprite(ctx, player) {
            const spriteRatio = player.sprite.width / player.sprite.height;
            player.height = 33;
            player.width = player.height * spriteRatio;

            ctx.save();
            ctx.translate(player.x, player.y);
            if (player.direction === 1) {  // Invertemos esta condição
                ctx.scale(-1, 1);
                ctx.translate(-player.width, 0);
            }

            if (player.spriteLoaded) {
                ctx.drawImage(player.sprite, 0, 0, player.sprite.width, player.sprite.height, 0, 0, player.width, player.height);
            } else {
                ctx.fillStyle = 'red';
                ctx.fillRect(0, 0, player.width, player.height);
            }

            ctx.restore();
        }

        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width && obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height && obj1.y + obj1.height > obj2.y;
        }

        function respawnPlayer() {
            player.x = GAME_WIDTH / 2;
            player.y = ground.y - player.height;
            player.verticalVelocity = 0;
        }

        function attackPlayer() {
            if (checkCollision(player, {x: boss.x - boss.attackRange/2, y: boss.y, width: boss.width + boss.attackRange, height: boss.height})) {
                player.lives--;
                if (player.lives <= 0) {
                    gameOver();
                } else {
                    respawnPlayer();
                }
            }
        }

        // Adicione esta nova função para verificar a colisão da bala
        function checkBulletCollision(bullet, target) {
            const bulletCenterX = bullet.x;
            const bulletCenterY = bullet.y;
            const targetCenterX = target.x + target.width / 2;
            const targetCenterY = target.y + target.height / 2;

            const distanceX = Math.abs(bulletCenterX - targetCenterX);
            const distanceY = Math.abs(bulletCenterY - targetCenterY);

            if (distanceX > (target.width / 2 + bullet.radius)) { return false; }
            if (distanceY > (target.height / 2 + bullet.radius)) { return false; }

            if (distanceX <= (target.width / 2)) { return true; }
            if (distanceY <= (target.height / 2)) { return true; }

            const cornerDistance = Math.pow(distanceX - target.width / 2, 2) +
                                   Math.pow(distanceY - target.height / 2, 2);

            return (cornerDistance <= Math.pow(bullet.radius, 2));
        }

        // Adicionar após as declarações iniciais (junto com player, bullet, etc.)
        const healthPowerUp = {
            x: 0,
            y: 0,
            width: 20,
            height: 20,
            active: false,
            healAmount: 1,
            respawnTime: 15000, // 15 segundos
            lastSpawnTime: 0
        };

        // Adicionar após as outras funções de desenho
        function drawHealthPowerUp(ctx) {
            if (!healthPowerUp.active) return;
            
            ctx.save();
            // Desenhar o power-up como uma cruz verde
            ctx.fillStyle = '#00ff00'; // Verde brilhante
            
            // Desenhar a parte vertical da cruz
            const crossThickness = healthPowerUp.width * 0.3;
            const x = healthPowerUp.x;
            const y = healthPowerUp.y;
            const w = healthPowerUp.width;
            const h = healthPowerUp.height;
            
            // Parte vertical da cruz
            ctx.fillRect(
                x + (w - crossThickness) / 2,
                y,
                crossThickness,
                h
            );
            
            // Parte horizontal da cruz
            ctx.fillRect(
                x,
                y + (h - crossThickness) / 2,
                w,
                crossThickness
            );
            
            // Adicionar um contorno preto
            ctx.strokeStyle = 'black'; // Alterado de 'white' para 'black'
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
            
            ctx.restore();
        }

        // Adicionar função para spawnar power-up
        function spawnHealthPowerUp() {
            if (!healthPowerUp.active && Date.now() - healthPowerUp.lastSpawnTime > healthPowerUp.respawnTime) {
                const availablePlatforms = platforms.filter(p => 
                    !robots.some(r => checkCollision(r, p)) && 
                    (!boss || !checkCollision(boss, p))
                );
                
                if (availablePlatforms.length > 0) {
                    const platform = availablePlatforms[Math.floor(Math.random() * availablePlatforms.length)];
                    healthPowerUp.active = true;
                    healthPowerUp.x = platform.x + (platform.width - healthPowerUp.width) / 2;
                    healthPowerUp.y = platform.y - healthPowerUp.height;
                }
            }
        }

        // Modifique a função que desenha o boss
        function drawBoss(ctx) {
            if (!boss.active) return;
            
            ctx.save();
            ctx.translate(boss.x, boss.y);
            
            // Determinar direção do boss baseado na posição do jogador
            boss.direction = boss.x < player.x ? 1 : -1;
            
            if (currentWave === 10 && zectromSpriteLoaded) {
                // Desenhar o sprite do Zectrom
                if (boss.direction === -1) {
                    ctx.scale(-1, 1);
                    ctx.translate(-boss.width, 0);
                }
                ctx.drawImage(zectromSprite, 0, 0, boss.width, boss.height);
            } else {
                // Fallback ou outros bosses
                ctx.fillStyle = boss.color;
                ctx.fillRect(0, 0, boss.width, boss.height);
            }
            
            // Desenhar barra de vida
            const healthBarWidth = boss.width;
            const healthBarHeight = 10;
            const healthPercentage = boss.health / boss.maxHealth;
            
            ctx.fillStyle = 'red';
            ctx.fillRect(0, -20, healthBarWidth, healthBarHeight);
            ctx.fillStyle = 'green';
            ctx.fillRect(0, -20, healthBarWidth * healthPercentage, healthBarHeight);
            
            ctx.restore();
            
            // Desenhar nome "Zectrom" acima do boss na wave 10 (após o restore)
            if (currentWave === 10) {
                ctx.fillStyle = 'white';
                ctx.font = '24px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('Zectrom', boss.x + boss.width / 2, boss.y - 30);
            }
            
            // Desenhar projéteis do boss
            boss.projectiles.forEach(proj => {
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ff4444';
                ctx.fill();
            });
        }

        // Adicione esta função para gerar o padrão de ruído para o chão
        function drawNoisyGround(ctx, x, y, width, height) {
            ctx.save();
            
            // Cor base do chão - mais escura
            ctx.fillStyle = '#202020';  // Alterado de #404040 para #202020
            ctx.fillRect(x, y, width, height);
            
            // Adicionar padrão de ruído com cores mais escuras
            for (let i = 0; i < width; i += 4) {
                for (let j = 0; j < height; j += 4) {
                    if (Math.random() < 0.3) {  // 30% de chance de desenhar um pixel de ruído
                        ctx.fillStyle = Math.random() < 0.5 ? '#151515' : '#252525';  // Cores mais escuras
                        ctx.fillRect(x + i, y + j, 4, 4);
                    }
                }
            }
            
            // Adicionar linhas horizontais mais escuras para textura
            ctx.strokeStyle = '#181818';  // Alterado de #353535 para #181818
            ctx.lineWidth = 1;
            for (let i = 0; i < height; i += 8) {
                ctx.beginPath();
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + width, y + i);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Adicionar função para desenhar plataformas com ruído
        function drawNoisyPlatform(ctx, x, y, width, height) {
            ctx.save();
            
            // Cor base da plataforma - vermelho escuro/marrom
            ctx.fillStyle = '#441111'; // Cor base marrom avermelhado escuro
            ctx.fillRect(x, y, width, height);
            
            // Adicionar padrão de ruído com variações da cor base
            for (let i = 0; i < width; i += 4) {
                for (let j = 0; j < height; j += 4) {
                    if (Math.random() < 0.3) {
                        ctx.fillStyle = Math.random() < 0.5 ? '#3a0e0e' : '#4d1414'; // Variações mais escuras e mais claras
                        ctx.fillRect(x + i, y + j, 4, 4);
                    }
                }
            }
            
            // Adicionar linhas horizontais mais escuras para textura
            ctx.strokeStyle = '#330808'; // Linhas um pouco mais escuras
            ctx.lineWidth = 1;
            for (let i = 0; i < height; i += 8) {
                ctx.beginPath();
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + width, y + i);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Adicione esta nova função para o ataque ultimate
        function fireUltimate() {
            const currentTime = Date.now();
            if (player.hasUltimate && currentTime - player.lastUltimateTime >= player.ultimateCooldown) {
                player.isUsingUltimate = true;
                player.lastUltimateTime = currentTime;
                
                // Sobrecarregar o jogador
                player.overheated = true;
                player.chargedShots = 0;
                
                // Efeito visual de flash
                ctx.save();
                ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                ctx.restore();
                
                // Timer para desativar o ultimate
                setTimeout(() => {
                    player.isUsingUltimate = false;
                }, player.ultimateDuration);
                
                // Timer para recuperar do sobreaquecimento
                setTimeout(() => {
                    player.overheated = false;
                }, player.overheatCooldown);
            }
        }

        // Adicione esta função no gameLoop para desenhar e aplicar dano do laser
        function updateUltimate() {
            if (player.isUsingUltimate) {
                // Desenhar o laser
                ctx.save();
                
                // Gradiente para o laser
                const gradient = ctx.createLinearGradient(
                    player.x + player.width/2,
                    player.y + player.height/2,
                    player.x + player.width/2 + (player.direction * GAME_WIDTH),
                    player.y + player.height/2
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0.6)');
                
                // Linha principal do laser - reduzida de 30 para 15
                ctx.beginPath();
                ctx.lineWidth = 15;
                ctx.strokeStyle = gradient;
                ctx.moveTo(player.x + player.width/2, player.y + player.height/2);
                ctx.lineTo(
                    player.x + player.width/2 + (player.direction * GAME_WIDTH),
                    player.y + player.height/2
                );
                ctx.stroke();
                
                // Efeito de brilho - reduzido de 15 para 8
                ctx.lineWidth = 8;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.stroke();
                
                ctx.restore();
                
                // Verificar colisões e aplicar dano
                robots.forEach((robot, index) => {
                    if (robot.y + robot.height > player.y && 
                        robot.y < player.y + player.height &&
                        ((player.direction === 1 && robot.x > player.x) ||
                         (player.direction === -1 && robot.x < player.x))) {
                        robot.health -= 100 * (16/1000); // 100 de dano por segundo (ajustado para frames)
                        if (robot.health <= 0) {
                            robots.splice(index, 1);
                            enemiesDefeated++;
                        }
                    }
                });
                
                // Verificar colisão com o boss
                if (boss.active && 
                    boss.y + boss.height > player.y && 
                    boss.y < player.y + player.height &&
                    ((player.direction === 1 && boss.x > player.x) ||
                     (player.direction === -1 && boss.x < player.x))) {
                    boss.health -= 100 * (16/1000); // 100 de dano por segundo
                    if (boss.health <= 0) {
                        boss.active = false;
                        showVictoryScreen();
                    }
                }
            }
        }

    </script>
</body>
</html>