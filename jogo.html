<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Plataforma 2D</title>
    <style>
        body {
            background-color: black;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            border: 1px solid white;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Jogador
        const player = {
            x: 50,
            y: canvas.height - 50,
            width: 30,
            height: 30,
            speed: 5,
            jumping: false,
            jumpStrength: 15,
            verticalVelocity: 0,
            lives: 3,
            canShoot: true,
            shootCooldown: 500,
            direction: 1,
            charging: false,
            chargeTime: 0,
            maxChargeTime: 1000
        };

        // Sistema de ondas
        let currentWave = 1;
        let enemiesDefeated = 0;
        const enemiesPerWave = 5;

        // Robôs
        const robots = [];

        // Plataformas
        const platforms = [
            {x: 200, y: 500, width: 200, height: 20},
            {x: 500, y: 400, width: 200, height: 20},
            {x: 800, y: 300, width: 200, height: 20},
            {x: 300, y: 200, width: 200, height: 20},
            {x: 700, y: 150, width: 200, height: 20}
        ];

        // Função para criar um novo robô
        function createRobot(isStrong) {
            const baseHealth = isStrong ? 50 : 10;
            const healthIncrease = currentWave - 1;
            const health = baseHealth + healthIncrease * (isStrong ? 10 : 2);

            return {
                x: Math.random() < 0.5 ? -30 : canvas.width,
                y: canvas.height - (isStrong ? 60 : 40),
                width: isStrong ? 40 : 30,
                height: isStrong ? 60 : 40,
                speed: isStrong ? 2 : 1,
                health: health,
                maxHealth: health,
                isStrong: isStrong,
                color: isStrong ? 'red' : 'orange',
                verticalVelocity: 0,
                jumping: false
            };
        }

        // Inicializar robôs para a primeira onda
        function initializeWave() {
            robots.length = 0;
            const strongRobots = Math.floor(currentWave / 3);
            for (let i = 0; i < enemiesPerWave; i++) {
                robots.push(createRobot(i < strongRobots));
            }
        }

        const bullet = {
            x: 0,
            y: 0,
            width: 10,
            height: 5,
            speed: 7,
            isActive: false,
            direction: 1,
            damage: 10
        };

        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.code === 'KeyX' && player.canShoot) {
                player.charging = true;
                player.chargeTime = 0;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            
            if (e.code === 'KeyX' && player.charging) {
                shootBullet();
                player.charging = false;
            }
        });

        function shootBullet() {
            bullet.x = player.direction === 1 ? player.x + player.width : player.x;
            bullet.y = player.y + player.height / 2;
            bullet.isActive = true;
            bullet.direction = player.direction;
            
            let chargeFactor = Math.min(player.chargeTime / player.maxChargeTime, 1);
            bullet.damage = 10 + Math.floor(chargeFactor * 40);
            
            player.canShoot = false;
            setTimeout(() => {
                player.canShoot = true;
            }, player.shootCooldown);
        }

        function reiniciarJogo() {
            player.x = 50;
            player.y = canvas.height - 50;
            player.lives = 3;
            player.canShoot = true;
            player.direction = 1;
            bullet.isActive = false;
            player.charging = false;
            player.chargeTime = 0;
            currentWave = 1;
            enemiesDefeated = 0;
            initializeWave();
        }

        function checkCollision(obj, platform) {
            return obj.x < platform.x + platform.width &&
                   obj.x + obj.width > platform.x &&
                   obj.y < platform.y + platform.height &&
                   obj.y + obj.height > platform.y;
        }

        function applyGravity(obj) {
            obj.verticalVelocity += 0.5;
            obj.y += obj.verticalVelocity;

            let onPlatform = false;
            for (let platform of platforms) {
                if (checkCollision(obj, platform) && obj.verticalVelocity > 0) {
                    obj.y = platform.y - obj.height;
                    obj.verticalVelocity = 0;
                    obj.jumping = false;
                    onPlatform = true;
                    break;
                }
            }

            if (obj.y > canvas.height - obj.height && !onPlatform) {
                obj.y = canvas.height - obj.height;
                obj.verticalVelocity = 0;
                obj.jumping = false;
            }
        }

        function findNearestPlatform(obj) {
            let nearestPlatform = null;
            let minDistance = Infinity;

            for (let platform of platforms) {
                if (platform.y < obj.y + obj.height) {
                    let distance = Math.abs(platform.x - obj.x);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestPlatform = platform;
                    }
                }
            }

            return nearestPlatform;
        }

        function moveObject(obj) {
            let nearestPlatform = findNearestPlatform(obj);

            // Movimento horizontal
            if (obj === player) {
                if (keys['ArrowLeft'] && obj.x > 0) {
                    obj.x -= obj.speed;
                    obj.direction = -1;
                }
                if (keys['ArrowRight'] && obj.x < canvas.width - obj.width) {
                    obj.x += obj.speed;
                    obj.direction = 1;
                }
            } else {
                // Movimento dos robôs
                if (nearestPlatform && Math.abs(nearestPlatform.x - obj.x) < 100) {
                    // Se estiver perto de uma plataforma, mova-se em direção a ela
                    if (nearestPlatform.x > obj.x) {
                        obj.x += obj.speed;
                        obj.direction = 1;
                    } else {
                        obj.x -= obj.speed;
                        obj.direction = -1;
                    }

                    // Se estiver na borda da plataforma, pule
                    if (Math.abs(nearestPlatform.x - obj.x) < obj.speed * 2 && !obj.jumping) {
                        obj.jumping = true;
                        obj.verticalVelocity = -obj.speed * 4;
                    }
                } else {
                    // Caso contrário, mova-se em direção ao jogador
                    if (player.x < obj.x) {
                        obj.x -= obj.speed;
                        obj.direction = -1;
                    } else if (player.x > obj.x) {
                        obj.x += obj.speed;
                        obj.direction = 1;
                    }
                }
            }

            // Limitar movimento às bordas do mapa
            obj.x = Math.max(0, Math.min(canvas.width - obj.width, obj.x));

            // Aplicar gravidade
            applyGravity(obj);
        }

        function gameLoop() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Desenhar plataformas
            ctx.fillStyle = 'gray';
            for (let platform of platforms) {
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            }

            // Lógica do jogador
            if (keys['Space'] && !player.jumping) {
                player.jumping = true;
                player.verticalVelocity = -player.jumpStrength;
            }

            moveObject(player);

            if (player.charging && player.chargeTime < player.maxChargeTime) {
                player.chargeTime += 16;
            }

            if (bullet.isActive) {
                bullet.x += bullet.speed * bullet.direction;
                if (bullet.x > canvas.width || bullet.x < 0) {
                    bullet.isActive = false;
                }
            }

            // Atualizar e desenhar robôs
            robots.forEach((robot, index) => {
                moveObject(robot);

                // Remova a lógica de salto aleatório, pois agora os robôs pulam com base nas plataformas

                ctx.fillStyle = robot.color;
                ctx.fillRect(robot.x, robot.y, robot.width, robot.height);

                // Colisão com o jogador
                if (checkCollision(player, robot)) {
                    player.lives -= 1;
                    if (player.lives <= 0) {
                        alert("Game Over!");
                        reiniciarJogo();
                    } else {
                        player.x = 50;
                        player.y = canvas.height - 50;
                        robots[index] = createRobot(robot.isStrong);
                    }
                }

                // Colisão com o tiro
                if (bullet.isActive && checkCollision(bullet, robot)) {
                    bullet.isActive = false;
                    robot.health -= bullet.damage;
                    if (robot.health <= 0) {
                        robots[index] = createRobot(robot.isStrong);
                        enemiesDefeated++;
                        if (enemiesDefeated >= enemiesPerWave) {
                            currentWave++;
                            enemiesDefeated = 0;
                            initializeWave();
                        }
                    }
                }

                // Desenha a barra de vida do robô
                ctx.fillStyle = 'green';
                let healthWidth = (robot.health / robot.maxHealth) * robot.width;
                ctx.fillRect(robot.x, robot.y - 10, healthWidth, 5);
            });

            ctx.fillStyle = 'blue';
            ctx.fillRect(player.x, player.y, player.width, player.height);

            if (bullet.isActive) {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            }

            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText(`Vidas: ${player.lives}`, 10, 30);
            ctx.fillText(`Onda: ${currentWave}`, 10, 50);

            if (!player.canShoot) {
                ctx.fillStyle = 'gray';
                ctx.fillRect(player.x, player.y - 10, player.width * (1 - (Date.now() % player.shootCooldown) / player.shootCooldown), 5);
            }

            // Desenha a barra de carga
            if (player.charging) {
                let chargeWidth = (player.chargeTime / player.maxChargeTime) * player.width;
                ctx.fillStyle = 'orange';
                ctx.fillRect(player.x, player.y - 15, chargeWidth, 5);
            }

            requestAnimationFrame(gameLoop);
        }

        initializeWave();
        gameLoop();
    </script>
</body>
</html>
